# üìã –≠–¢–ê–ü 4.1: FREQAI INTEGRATION
# Freqtrade Multi-Bot System - –ê–¥–∞–ø—Ç–∏–≤–Ω–æ–µ ML –¥–ª—è –∞–ª–≥–æ—Ç—Ä–µ–π–¥–∏–Ω–≥–∞

**–í—Ä–µ–º—è –≤—ã–ø–æ–ª–Ω–µ–Ω–∏—è:** 6 —á–∞—Å–æ–≤
**–¶–µ–ª—å:** –†–µ–∞–ª–∏–∑–æ–≤–∞—Ç—å –ø–æ–ª–Ω–æ—Ü–µ–Ω–Ω—É—é FreqAI –∏–Ω—Ç–µ–≥—Ä–∞—Ü–∏—é –¥–ª—è –∞–¥–∞–ø—Ç–∏–≤–Ω–æ–≥–æ –º–∞—à–∏–Ω–Ω–æ–≥–æ –æ–±—É—á–µ–Ω–∏—è –≤ —Ç–æ—Ä–≥–æ–≤–ª–µ

---

## üéØ –ó–ê–î–ê–ß–ò –≠–¢–ê–ü–ê

### ‚úÖ –ó–∞–¥–∞—á–∞ 4.1.1: FreqAI Core Setup (2 —á–∞—Å–∞)

**–¶–µ–ª—å:** –ù–∞—Å—Ç—Ä–æ–∏—Ç—å FreqAI –∏–Ω—Ñ—Ä–∞—Å—Ç—Ä—É–∫—Ç—É—Ä—É –∏ –±–∞–∑–æ–≤—ã–µ –∫–æ–º–ø–æ–Ω–µ–Ω—Ç—ã

#### 1. –£—Å—Ç–∞–Ω–æ–≤–∫–∞ FreqAI –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–µ–π
#### 2. –°–æ–∑–¥–∞–Ω–∏–µ FreqAI –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏–∏
#### 3. –ù–∞—Å—Ç—Ä–æ–π–∫–∞ prediction models (LightGBM, CatBoost, PyTorch)
#### 4. –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è FreqAI —Å–µ—Ä–≤–∏—Å–∞

### ‚úÖ –ó–∞–¥–∞—á–∞ 4.1.2: FreqAI Strategy Development (2 —á–∞—Å–∞)

**–¶–µ–ª—å:** –°–æ–∑–¥–∞—Ç—å AI-powered —Ç–æ—Ä–≥–æ–≤—ã–µ —Å—Ç—Ä–∞—Ç–µ–≥–∏–∏

#### 1. –†–∞–∑—Ä–∞–±–æ—Ç–∫–∞ FreqAIExampleStrategy —Å rich features
#### 2. –†–µ–∞–ª–∏–∑–∞—Ü–∏—è feature engineering pipeline
#### 3. –ù–∞—Å—Ç—Ä–æ–π–∫–∞ labels –∏ target values
#### 4. –¢–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ —Å—Ç—Ä–∞—Ç–µ–≥–∏–∏ –≤ dry-run —Ä–µ–∂–∏–º–µ

### ‚úÖ –ó–∞–¥–∞—á–∞ 4.1.3: Adaptive Retraining System (1.5 —á–∞—Å–∞)

**–¶–µ–ª—å:** –†–µ–∞–ª–∏–∑–æ–≤–∞—Ç—å self-adaptive retraining –≤–æ –≤—Ä–µ–º—è live —Ç–æ—Ä–≥–æ–≤

#### 1. –ù–∞—Å—Ç—Ä–æ–π–∫–∞ background retraining thread
#### 2. –†–µ–∞–ª–∏–∑–∞—Ü–∏—è model versioning –∏ storage
#### 3. –ù–∞—Å—Ç—Ä–æ–π–∫–∞ retraining triggers (time-based, performance-based)
#### 4. Model rollback –∏ recovery mechanisms

### ‚úÖ –ó–∞–¥–∞—á–∞ 4.1.4: FreqAI API Integration (0.5 —á–∞—Å–∞)

**–¶–µ–ª—å:** –ò–Ω—Ç–µ–≥—Ä–∏—Ä–æ–≤–∞—Ç—å FreqAI —Å –æ—Å–Ω–æ–≤–Ω—ã–º API —Å–∏—Å—Ç–µ–º—ã

#### 1. –°–æ–∑–¥–∞–Ω–∏–µ FreqAI management endpoints
#### 2. Model performance monitoring APIs
#### 3. Retraining control endpoints
#### 4. Integration —Å MCP Bridge –¥–ª—è AI —É–ø—Ä–∞–≤–ª–µ–Ω–∏—è

---

## üöÄ –î–ï–¢–ê–õ–¨–ù–ê–Ø –†–ï–ê–õ–ò–ó–ê–¶–ò–Ø

### 1. FreqAI Core Setup (2 —á–∞—Å–∞)

#### –£—Å—Ç–∞–Ω–æ–≤–∫–∞ FreqAI –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–µ–π
FreqAI —Ç—Ä–µ–±—É–µ—Ç —Å–ø–µ—Ü–∏—Ñ–∏—á–µ—Å–∫–∏—Ö ML –±–∏–±–ª–∏–æ—Ç–µ–∫. –î–æ–±–∞–≤—å—Ç–µ –≤ `requirements.txt`:

```python
# FreqAI Core Dependencies (https://github.com/freqtrade/freqtrade)
freqtrade[freqai]==2023.12

# Machine Learning Libraries
lightgbm==4.0.0
catboost==1.2.0
xgboost==2.0.0

# Optional: For advanced models
torch==2.1.0  # For PyTorch models
scikit-learn==1.3.0
pandas==2.1.0
numpy==1.24.0

# Data processing
ta-lib==0.4.25  # Technical analysis
scipy==1.11.0
```

**–£—Å—Ç–∞–Ω–æ–≤–∫–∞ —á–µ—Ä–µ–∑ uv:**
```bash
uv pip install -r requirements-freqai.txt
```

#### –°–æ–∑–¥–∞–Ω–∏–µ FreqAI –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏–∏
**–§–∞–π–ª:** `core_server/config/freqai_config.json`

```json
{
  "freqai": {
    "enabled": true,
    "identifier": "freqai_model",
    "feature_parameters": {
      "include_timeframes": ["5m", "15m", "1h"],
      "include_corr_pairlist": ["BTC/USDT", "ETH/USDT"],
      "label_period_candles": 24
    },
    "data_split_parameters": {
      "test_size": 0.25,
      "random_state": 42
    },
    "model_training_parameters": {
      "n_estimators": 1000,
      "learning_rate": 0.05,
      "max_depth": 6
    },
    "rl_config": {},
    "backtesting": {
      "enabled": true,
      "retention_ratio": 0.9
    }
  }
}
```

#### –ù–∞—Å—Ç—Ä–æ–π–∫–∞ prediction models
**–§–∞–π–ª:** `freqtrade/freqai/prediction_models/CustomRegressor.py`

```python
import logging
from typing import Any, Dict
import numpy as np
import pandas as pd
from freqai.prediction_models.BaseRegressionModel import BaseRegressionModel

logger = logging.getLogger(__name__)

class CustomRegressor(BaseRegressionModel):
    """
    Custom FreqAI regression model with advanced feature engineering
    """

    def __init__(self, **kwargs):
        super().__init__(**kwargs)

    def fit(self, dk: Dict[str, Any], **kwargs) -> Any:
        """
        Train the model
        """
        features = dk['features']
        labels = dk['labels']

        # Custom preprocessing
        features = self.preprocess_features(features)

        # Train model
        self.model.fit(features, labels)

        return self.model

    def predict(self, dk: Dict[str, Any], **kwargs) -> Any:
        """
        Make predictions
        """
        features = dk['features']
        features = self.preprocess_features(features)

        predictions = self.model.predict(features)
        return predictions

    def preprocess_features(self, features: pd.DataFrame) -> pd.DataFrame:
        """
        Advanced feature preprocessing
        """
        # Remove outliers
        features = self.remove_outliers(features)

        # Normalize features
        features = self.normalize_features(features)

        # Add custom features
        features = self.add_custom_features(features)

        return features

    def remove_outliers(self, df: pd.DataFrame) -> pd.DataFrame:
        """Remove statistical outliers"""
        for col in df.columns:
            if df[col].dtype in ['float64', 'int64']:
                q1 = df[col].quantile(0.25)
                q3 = df[col].quantile(0.75)
                iqr = q3 - q1
                lower_bound = q1 - (1.5 * iqr)
                upper_bound = q3 + (1.5 * iqr)
                df = df[(df[col] >= lower_bound) & (df[col] <= upper_bound)]
        return df

    def normalize_features(self, df: pd.DataFrame) -> pd.DataFrame:
        """Normalize features using robust scaling"""
        from sklearn.preprocessing import RobustScaler

        scaler = RobustScaler()
        numeric_cols = df.select_dtypes(include=[np.number]).columns
        df[numeric_cols] = scaler.fit_transform(df[numeric_cols])

        return df

    def add_custom_features(self, df: pd.DataFrame) -> pd.DataFrame:
        """Add custom technical indicators"""
        # RSI divergence
        df['rsi_divergence'] = df['rsi'] - df['rsi'].rolling(14).mean()

        # Volume momentum
        df['volume_momentum'] = df['volume'].pct_change(5)

        # Price momentum
        df['price_momentum'] = df['close'].pct_change(10)

        return df
```

#### –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è FreqAI —Å–µ—Ä–≤–∏—Å–∞
**–§–∞–π–ª:** `core_server/services/freqai_service.py`

```python
"""
FreqAI Service –¥–ª—è —É–ø—Ä–∞–≤–ª–µ–Ω–∏—è ML –º–æ–¥–µ–ª—è–º–∏ –≤ —Ç–æ—Ä–≥–æ–≤–ª–µ
"""

import asyncio
import logging
from typing import Dict, Any, Optional, List
from pathlib import Path
import json
import pandas as pd
from datetime import datetime, timedelta

from freqtrade.freqai import IFreqaiModel
from freqtrade.configuration import Configuration
from freqtrade.enums import RunMode

logger = logging.getLogger(__name__)

class FreqAIService:
    """
    –°–µ—Ä–≤–∏—Å –¥–ª—è —É–ø—Ä–∞–≤–ª–µ–Ω–∏—è FreqAI –º–æ–¥–µ–ª—è–º–∏
    """

    def __init__(self, config_path: str = "core_server/config/freqai_config.json"):
        self.config_path = config_path
        self.config = self._load_config()
        self.models: Dict[str, IFreqaiModel] = {}
        self.training_tasks: Dict[str, asyncio.Task] = {}
        self._initialized = False

    def _load_config(self) -> Dict[str, Any]:
        """–ó–∞–≥—Ä—É–∑–∫–∞ –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏–∏ FreqAI"""
        with open(self.config_path, 'r') as f:
            return json.load(f)

    async def initialize(self) -> bool:
        """–ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è FreqAI —Å–µ—Ä–≤–∏—Å–∞"""
        try:
            logger.info("Initializing FreqAI service...")

            # –ó–∞–≥—Ä—É–∑–∫–∞ —Å—É—â–µ—Å—Ç–≤—É—é—â–∏—Ö –º–æ–¥–µ–ª–µ–π
            await self._load_existing_models()

            # –ó–∞–ø—É—Å–∫ background retraining
            asyncio.create_task(self._background_retraining_loop())

            self._initialized = True
            logger.info("FreqAI service initialized successfully")
            return True

        except Exception as e:
            logger.error(f"Failed to initialize FreqAI service: {e}")
            return False

    async def _load_existing_models(self):
        """–ó–∞–≥—Ä—É–∑–∫–∞ —Å—É—â–µ—Å—Ç–≤—É—é—â–∏—Ö –æ–±—É—á–µ–Ω–Ω—ã—Ö –º–æ–¥–µ–ª–µ–π"""
        model_dir = Path("user_data/models")
        if not model_dir.exists():
            return

        for model_file in model_dir.glob("*.pkl"):
            model_name = model_file.stem
            try:
                # –ó–∞–≥—Ä—É–∑–∫–∞ –º–æ–¥–µ–ª–∏ —á–µ—Ä–µ–∑ FreqAI
                model = await self._load_model_from_file(model_file)
                self.models[model_name] = model
                logger.info(f"Loaded existing model: {model_name}")
            except Exception as e:
                logger.error(f"Failed to load model {model_name}: {e}")

    async def create_model(self, model_name: str, model_type: str = "LightGBMRegressor",
                          strategy_config: Dict[str, Any] = None) -> bool:
        """–°–æ–∑–¥–∞–Ω–∏–µ –Ω–æ–≤–æ–π FreqAI –º–æ–¥–µ–ª–∏"""

        try:
            # –°–æ–∑–¥–∞–Ω–∏–µ –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏–∏ Freqtrade
            ft_config = Configuration.from_files([])
            ft_config.update(self.config)

            # –ù–∞—Å—Ç—Ä–æ–π–∫–∞ —Å—Ç—Ä–∞—Ç–µ–≥–∏–∏
            if strategy_config:
                ft_config.update({"strategy": strategy_config})

            # –°–æ–∑–¥–∞–Ω–∏–µ –º–æ–¥–µ–ª–∏
            if model_type == "LightGBMRegressor":
                from freqtrade.freqai.prediction_models.LightGBMRegressor import LightGBMRegressor
                model = LightGBMRegressor(config=ft_config)
            elif model_type == "CatboostRegressor":
                from freqtrade.freqai.prediction_models.CatboostRegressor import CatboostRegressor
                model = CatboostRegressor(config=ft_config)
            else:
                raise ValueError(f"Unsupported model type: {model_type}")

            # –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –º–æ–¥–µ–ª–∏
            await model.start()

            self.models[model_name] = model
            logger.info(f"Created new FreqAI model: {model_name}")

            return True

        except Exception as e:
            logger.error(f"Failed to create model {model_name}: {e}")
            return False

    async def train_model(self, model_name: str, data_path: str = None) -> Dict[str, Any]:
        """–û–±—É—á–µ–Ω–∏–µ –º–æ–¥–µ–ª–∏ –Ω–∞ –¥–∞–Ω–Ω—ã—Ö"""

        if model_name not in self.models:
            return {"error": f"Model {model_name} not found"}

        try:
            model = self.models[model_name]

            # –ó–∞–≥—Ä—É–∑–∫–∞ –¥–∞–Ω–Ω—ã—Ö –¥–ª—è –æ–±—É—á–µ–Ω–∏—è
            if data_path:
                # –ó–∞–≥—Ä—É–∑–∫–∞ –∏–∑ —Ñ–∞–π–ª–∞
                data = pd.read_pickle(data_path)
            else:
                # –ì–µ–Ω–µ—Ä–∞—Ü–∏—è –¥–∞–Ω–Ω—ã—Ö —á–µ—Ä–µ–∑ Freqtrade
                data = await self._generate_training_data(model)

            # –û–±—É—á–µ–Ω–∏–µ –º–æ–¥–µ–ª–∏
            training_result = await model.fit(data)

            # –°–æ—Ö—Ä–∞–Ω–µ–Ω–∏–µ –º–æ–¥–µ–ª–∏
            await self._save_model(model_name, model)

            result = {
                "status": "success",
                "model_name": model_name,
                "training_metrics": training_result,
                "timestamp": datetime.now().isoformat()
            }

            logger.info(f"Successfully trained model: {model_name}")
            return result

        except Exception as e:
            logger.error(f"Failed to train model {model_name}: {e}")
            return {"error": str(e)}

    async def predict(self, model_name: str, features: Dict[str, Any]) -> Dict[str, Any]:
        """–ü–æ–ª—É—á–µ–Ω–∏–µ –ø—Ä–µ–¥—Å–∫–∞–∑–∞–Ω–∏—è –æ—Ç –º–æ–¥–µ–ª–∏"""

        if model_name not in self.models:
            return {"error": f"Model {model_name} not found"}

        try:
            model = self.models[model_name]

            # –ü—Ä–µ–æ–±—Ä–∞–∑–æ–≤–∞–Ω–∏–µ features –≤ DataFrame
            df = pd.DataFrame([features])

            # –ü–æ–ª—É—á–µ–Ω–∏–µ –ø—Ä–µ–¥—Å–∫–∞–∑–∞–Ω–∏—è
            prediction = await model.predict(df)

            result = {
                "model_name": model_name,
                "prediction": float(prediction[0]),
                "confidence": self._calculate_confidence(prediction),
                "timestamp": datetime.now().isoformat()
            }

            return result

        except Exception as e:
            logger.error(f"Failed to get prediction from {model_name}: {e}")
            return {"error": str(e)}

    async def start_retraining(self, model_name: str, interval_hours: int = 24) -> bool:
        """–ó–∞–ø—É—Å–∫ –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–æ–≥–æ retraining"""

        if model_name not in self.models:
            logger.error(f"Model {model_name} not found")
            return False

        if model_name in self.training_tasks:
            logger.warning(f"Retraining already running for {model_name}")
            return False

        async def retraining_loop():
            while True:
                try:
                    logger.info(f"Starting retraining for {model_name}")

                    # –ü–æ–ª—É—á–µ–Ω–∏–µ —Å–≤–µ–∂–∏—Ö –¥–∞–Ω–Ω—ã—Ö
                    new_data = await self._get_new_training_data(model_name)

                    if new_data is not None:
                        # Retraining –º–æ–¥–µ–ª–∏
                        result = await self.train_model(model_name, new_data)
                        if "error" not in result:
                            logger.info(f"Successfully retrained {model_name}")
                        else:
                            logger.error(f"Failed to retrain {model_name}: {result['error']}")

                    # –û–∂–∏–¥–∞–Ω–∏–µ —Å–ª–µ–¥—É—é—â–µ–≥–æ retraining
                    await asyncio.sleep(interval_hours * 3600)

                except Exception as e:
                    logger.error(f"Error in retraining loop for {model_name}: {e}")
                    await asyncio.sleep(300)  # 5 –º–∏–Ω—É—Ç –ø–∞—É–∑—ã –ø—Ä–∏ –æ—à–∏–±–∫–µ

        task = asyncio.create_task(retraining_loop())
        self.training_tasks[model_name] = task

        logger.info(f"Started retraining for {model_name} (every {interval_hours}h)")
        return True

    async def stop_retraining(self, model_name: str) -> bool:
        """–û—Å—Ç–∞–Ω–æ–≤–∫–∞ –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–æ–≥–æ retraining"""

        if model_name not in self.training_tasks:
            logger.warning(f"No retraining task found for {model_name}")
            return False

        task = self.training_tasks[model_name]
        task.cancel()

        try:
            await task
        except asyncio.CancelledError:
            pass

        del self.training_tasks[model_name]
        logger.info(f"Stopped retraining for {model_name}")
        return True

    async def get_model_status(self, model_name: str) -> Dict[str, Any]:
        """–ü–æ–ª—É—á–µ–Ω–∏–µ —Å—Ç–∞—Ç—É—Å–∞ –º–æ–¥–µ–ª–∏"""

        if model_name not in self.models:
            return {"error": f"Model {model_name} not found"}

        model = self.models[model_name]

        status = {
            "model_name": model_name,
            "is_trained": hasattr(model, 'model') and model.model is not None,
            "retraining_active": model_name in self.training_tasks,
            "last_training": getattr(model, 'last_training_time', None),
            "performance_metrics": getattr(model, 'performance_metrics', {}),
            "feature_importance": getattr(model, 'feature_importance', {}),
        }

        return status

    async def _background_retraining_loop(self):
        """–§–æ–Ω–æ–≤–∞—è –ø—Ä–æ–≤–µ—Ä–∫–∞ –Ω–µ–æ–±—Ö–æ–¥–∏–º–æ—Å—Ç–∏ retraining"""
        while True:
            try:
                # –ü—Ä–æ–≤–µ—Ä–∫–∞ –≤—Å–µ—Ö –º–æ–¥–µ–ª–µ–π
                for model_name in list(self.models.keys()):
                    await self._check_model_performance(model_name)

                await asyncio.sleep(3600)  # –ü—Ä–æ–≤–µ—Ä–∫–∞ –∫–∞–∂–¥—ã–π —á–∞—Å

            except Exception as e:
                logger.error(f"Error in background retraining loop: {e}")
                await asyncio.sleep(300)

    async def _check_model_performance(self, model_name: str):
        """–ü—Ä–æ–≤–µ—Ä–∫–∞ –ø—Ä–æ–∏–∑–≤–æ–¥–∏—Ç–µ–ª—å–Ω–æ—Å—Ç–∏ –º–æ–¥–µ–ª–∏ –∏ –∑–∞–ø—É—Å–∫ retraining –µ—Å–ª–∏ –Ω—É–∂–Ω–æ"""

        try:
            status = await self.get_model_status(model_name)
            metrics = status.get('performance_metrics', {})

            # –ü—Ä–æ–≤–µ—Ä–∫–∞ –º–µ—Ç—Ä–∏–∫ –ø—Ä–æ–∏–∑–≤–æ–¥–∏—Ç–µ–ª—å–Ω–æ—Å—Ç–∏
            accuracy = metrics.get('accuracy', 1.0)
            if accuracy < 0.7:  # –ï—Å–ª–∏ —Ç–æ—á–Ω–æ—Å—Ç—å –Ω–∏–∂–µ 70%
                logger.warning(f"Model {model_name} performance degraded (accuracy: {accuracy})")

                # –ó–∞–ø—É—Å–∫ retraining –µ—Å–ª–∏ –Ω–µ –∑–∞–ø—É—â–µ–Ω
                if not status.get('retraining_active'):
                    await self.start_retraining(model_name, interval_hours=6)  # –ß–∞—Å—Ç—ã–π retraining

        except Exception as e:
            logger.error(f"Error checking performance for {model_name}: {e}")

    async def _generate_training_data(self, model) -> pd.DataFrame:
        """–ì–µ–Ω–µ—Ä–∞—Ü–∏—è —Ç—Ä–µ–Ω–∏—Ä–æ–≤–æ—á–Ω—ã—Ö –¥–∞–Ω–Ω—ã—Ö —á–µ—Ä–µ–∑ Freqtrade"""
        # –†–µ–∞–ª–∏–∑–∞—Ü–∏—è –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏ –¥–∞–Ω–Ω—ã—Ö –¥–ª—è –æ–±—É—á–µ–Ω–∏—è
        # –≠—Ç–æ –±—É–¥–µ—Ç –∑–∞–≤–∏—Å–µ—Ç—å –æ—Ç –∫–æ–Ω–∫—Ä–µ—Ç–Ω–æ–π —Å—Ç—Ä–∞—Ç–µ–≥–∏–∏
        pass

    async def _get_new_training_data(self, model_name: str) -> Optional[str]:
        """–ü–æ–ª—É—á–µ–Ω–∏–µ –Ω–æ–≤—ã—Ö –¥–∞–Ω–Ω—ã—Ö –¥–ª—è retraining"""
        # –†–µ–∞–ª–∏–∑–∞—Ü–∏—è –ø–æ–ª—É—á–µ–Ω–∏—è —Å–≤–µ–∂–∏—Ö –¥–∞–Ω–Ω—ã—Ö
        pass

    async def _save_model(self, model_name: str, model):
        """–°–æ—Ö—Ä–∞–Ω–µ–Ω–∏–µ –º–æ–¥–µ–ª–∏ –Ω–∞ –¥–∏—Å–∫"""
        # –†–µ–∞–ª–∏–∑–∞—Ü–∏—è —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏—è –º–æ–¥–µ–ª–∏
        pass

    async def _load_model_from_file(self, model_file: Path):
        """–ó–∞–≥—Ä—É–∑–∫–∞ –º–æ–¥–µ–ª–∏ –∏–∑ —Ñ–∞–π–ª–∞"""
        # –†–µ–∞–ª–∏–∑–∞—Ü–∏—è –∑–∞–≥—Ä—É–∑–∫–∏ –º–æ–¥–µ–ª–∏
        pass

    def _calculate_confidence(self, prediction) -> float:
        """–†–∞—Å—á–µ—Ç —É–≤–µ—Ä–µ–Ω–Ω–æ—Å—Ç–∏ –ø—Ä–µ–¥—Å–∫–∞–∑–∞–Ω–∏—è"""
        # –ü—Ä–æ—Å—Ç–∞—è –æ—Ü–µ–Ω–∫–∞ —É–≤–µ—Ä–µ–Ω–Ω–æ—Å—Ç–∏
        return 0.8  # –í —Ä–µ–∞–ª—å–Ω–æ—Å—Ç–∏ —Ä–∞—Å—Å—á–∏—Ç—ã–≤–∞–µ—Ç—Å—è –Ω–∞ –æ—Å–Ω–æ–≤–µ –º–æ–¥–µ–ª–∏

# –ì–ª–æ–±–∞–ª—å–Ω—ã–π —ç–∫–∑–µ–º–ø–ª—è—Ä —Å–µ—Ä–≤–∏—Å–∞
freqai_service = FreqAIService()
```

### 2. FreqAI Strategy Development (2 —á–∞—Å–∞)

#### –†–∞–∑—Ä–∞–±–æ—Ç–∫–∞ FreqAIExampleStrategy
**–§–∞–π–ª:** `freqtrade/strategies/FreqAIExampleStrategy.py`

```python
import logging
import numpy as np
import pandas as pd
import talib.abstract as ta
from freqtrade.strategy import IStrategy, DecimalParameter, IntParameter
from freqtrade.persistence import Trade
from pandas import DataFrame
from datetime import datetime, timedelta

logger = logging.getLogger(__name__)

class FreqAIExampleStrategy(IStrategy):
    """
    FreqAI Example Strategy —Å rich feature engineering
    """

    INTERFACE_VERSION = 3

    # –û–ø—Ç–∏–º–∏–∑–∏—Ä—É–µ–º—ã–µ –ø–∞—Ä–∞–º–µ—Ç—Ä—ã
    minimal_roi = {"0": 0.1}
    stoploss = -0.10
    timeframe = '5m'

    # FreqAI –ø–∞—Ä–∞–º–µ—Ç—Ä—ã
    freqai_required_spaces = ['buy', 'sell', 'roi', 'stoploss']

    # –ü–µ—Ä–∏–æ–¥—ã –¥–ª—è feature engineering
    feature_periods = [6, 12, 24, 48, 96]  # 30m, 1h, 2h, 4h, 8h

    def feature_engineering_expand_all(self, dataframe: DataFrame, period: int,
                                     metadata: dict, **kwargs) -> DataFrame:
        """
        –°–æ–∑–¥–∞–Ω–∏–µ —Ä–∞—Å—à–∏—Ä–µ–Ω–Ω—ã—Ö features –¥–ª—è FreqAI
        """
        dataframe = self.feature_engineering_expand_basic(dataframe, metadata, **kwargs)
        dataframe = self.feature_engineering_expand_indicators(dataframe, metadata, **kwargs)
        dataframe = self.feature_engineering_expand_correlations(dataframe, metadata, **kwargs)

        return dataframe

    def feature_engineering_expand_basic(self, dataframe: DataFrame,
                                       metadata: dict, **kwargs) -> DataFrame:
        """
        –ë–∞–∑–æ–≤—ã–µ price –∏ volume features
        """
        # Price features
        dataframe['price_change'] = dataframe['close'].pct_change()
        dataframe['price_change_abs'] = dataframe['close'].diff()

        for period in self.feature_periods:
            # Price momentum
            dataframe[f'price_momentum_{period}'] = dataframe['close'].pct_change(period)

            # Volume features
            dataframe[f'volume_ratio_{period}'] = dataframe['volume'] / dataframe['volume'].rolling(period).mean()
            dataframe[f'volume_change_{period}'] = dataframe['volume'].pct_change(period)

            # Volatility
            dataframe[f'volatility_{period}'] = dataframe['close'].rolling(period).std() / dataframe['close'].rolling(period).mean()

        return dataframe

    def feature_engineering_expand_indicators(self, dataframe: DataFrame,
                                            metadata: dict, **kwargs) -> DataFrame:
        """
        –¢–µ—Ö–Ω–∏—á–µ—Å–∫–∏–µ –∏–Ω–¥–∏–∫–∞—Ç–æ—Ä—ã
        """
        # RSI
        dataframe['rsi'] = ta.RSI(dataframe, timeperiod=14)
        dataframe['rsi_overbought'] = (dataframe['rsi'] > 70).astype(int)
        dataframe['rsi_oversold'] = (dataframe['rsi'] < 30).astype(int)

        # MACD
        macd, macdsignal, macdhist = ta.MACD(dataframe['close'], fastperiod=12, slowperiod=26, signalperiod=9)
        dataframe['macd'] = macd
        dataframe['macd_signal'] = macdsignal
        dataframe['macd_hist'] = macdhist
        dataframe['macd_crossover'] = (macd > macdsignal).astype(int)

        # Bollinger Bands
        upperband, middleband, lowerband = ta.BBANDS(dataframe['close'], timeperiod=20, nbdevup=2, nbdevdn=2, matype=0)
        dataframe['bb_upper'] = upperband
        dataframe['bb_middle'] = middleband
        dataframe['bb_lower'] = lowerband
        dataframe['bb_position'] = (dataframe['close'] - lowerband) / (upperband - lowerband)

        # Stochastic
        slowk, slowd = ta.STOCH(dataframe['high'], dataframe['low'], dataframe['close'],
                               fastk_period=14, slowk_period=3, slowd_period=3)
        dataframe['stoch_k'] = slowk
        dataframe['stoch_d'] = slowd

        # Williams %R
        dataframe['willr'] = ta.WILLR(dataframe['high'], dataframe['low'], dataframe['close'], timeperiod=14)

        # CCI
        dataframe['cci'] = ta.CCI(dataframe['high'], dataframe['low'], dataframe['close'], timeperiod=14)

        return dataframe

    def feature_engineering_expand_correlations(self, dataframe: DataFrame,
                                              metadata: dict, **kwargs) -> DataFrame:
        """
        –ö–æ—Ä—Ä–µ–ª—è—Ü–∏–æ–Ω–Ω—ã–µ features —Å –¥—Ä—É–≥–∏–º–∏ –ø–∞—Ä–∞–º–∏
        """
        # –í –±–∞–∑–æ–≤–æ–π —Ä–µ–∞–ª–∏–∑–∞—Ü–∏–∏ —ç—Ç–æ –º–æ–∂–µ—Ç –±—ã—Ç—å –∑–∞–≥–ª—É—à–∫–∞
        # –í –ø—Ä–æ–¥–∞–∫—à–µ–Ω–µ –∑–¥–µ—Å—å –±—É–¥—É—Ç –∫–æ—Ä—Ä–µ–ª—è—Ü–∏–∏ —Å BTC, ETH –∏ —Ç.–¥.

        # –ü—Ä–∏–º–µ—Ä: –∫–æ—Ä—Ä–µ–ª—è—Ü–∏—è —Å –æ–±—ä–µ–º–æ–º
        dataframe['volume_price_corr'] = dataframe['volume'].rolling(24).corr(dataframe['close'])

        return dataframe

    def set_freqai_targets(self, dataframe: DataFrame, metadata: dict, **kwargs) -> DataFrame:
        """
        –£—Å—Ç–∞–Ω–æ–≤–∫–∞ target values –¥–ª—è FreqAI
        """
        # Buy signal (1 –µ—Å–ª–∏ —á–µ—Ä–µ–∑ 24 —Å–≤–µ—á–∏ —Ü–µ–Ω–∞ –≤—ã—Ä–∞—Å—Ç–µ—Ç > 1%)
        dataframe['&-target_buy'] = (
            (dataframe['close'].shift(-24) > dataframe['close'] * 1.01)
        ).astype(int)

        # Sell signal (1 –µ—Å–ª–∏ —á–µ—Ä–µ–∑ 24 —Å–≤–µ—á–∏ —Ü–µ–Ω–∞ —É–ø–∞–¥–µ—Ç > 1%)
        dataframe['&-target_sell'] = (
            (dataframe['close'].shift(-24) < dataframe['close'] * 0.99)
        ).astype(int)

        # ROI target (–æ–∂–∏–¥–∞–µ–º–∞—è –¥–æ—Ö–æ–¥–Ω–æ—Å—Ç—å —á–µ—Ä–µ–∑ 24 —Å–≤–µ—á–∏)
        dataframe['&-target_roi'] = (
            dataframe['close'].shift(-24) / dataframe['close'] - 1
        )

        # Stoploss target (1 –µ—Å–ª–∏ –Ω—É–∂–Ω–æ —Å—Ç–æ–ø–∏—Ç—å –ø–æ–∑–∏—Ü–∏—é)
        dataframe['&-target_stoploss'] = (
            (dataframe['close'].shift(-24) < dataframe['close'] * 0.95)
        ).astype(int)

        return dataframe

    def populate_indicators(self, dataframe: DataFrame, metadata: dict) -> DataFrame:
        """
        Populate indicators (–¥–ª—è —Å–æ–≤–º–µ—Å—Ç–∏–º–æ—Å—Ç–∏ —Å –æ–±—ã—á–Ω—ã–º–∏ —Å—Ç—Ä–∞—Ç–µ–≥–∏—è–º–∏)
        """
        return dataframe

    def populate_entry_trend(self, dataframe: DataFrame, metadata: dict) -> DataFrame:
        """
        Entry signals (–¥–ª—è —Å–æ–≤–º–µ—Å—Ç–∏–º–æ—Å—Ç–∏)
        """
        dataframe.loc[:, 'enter_long'] = 0
        dataframe.loc[:, 'enter_short'] = 0

        # –í FreqAI —Å—Ç—Ä–∞—Ç–µ–≥–∏—è—Ö entry signals –æ–±—ã—á–Ω–æ –Ω–µ –∏—Å–ø–æ–ª—å–∑—É—é—Ç—Å—è
        # –í–º–µ—Å—Ç–æ —ç—Ç–æ–≥–æ –∏—Å–ø–æ–ª—å–∑—É—é—Ç—Å—è –ø—Ä–µ–¥—Å–∫–∞–∑–∞–Ω–∏—è –º–æ–¥–µ–ª–∏

        return dataframe

    def populate_exit_trend(self, dataframe: DataFrame, metadata: dict) -> DataFrame:
        """
        Exit signals (–¥–ª—è —Å–æ–≤–º–µ—Å—Ç–∏–º–æ—Å—Ç–∏)
        """
        dataframe.loc[:, 'exit_long'] = 0
        dataframe.loc[:, 'exit_short'] = 0

        return dataframe

    def leverage(self, pair: str, current_time, current_rate: float,
                proposed_leverage: float, max_leverage: float,
                entry_tag: str | None, side: str, **kwargs) -> float:
        """
        Leverage calculation
        """
        return 1.0

    def confirm_trade_entry(self, pair: str, order_type: str, amount: float,
                          rate: float, time_in_force: str, current_time,
                          entry_tag: str | None, side: str, **kwargs) -> bool:
        """
        Trade entry confirmation
        """
        # –í FreqAI –º–æ–∂–Ω–æ –¥–æ–±–∞–≤–∏—Ç—å –¥–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω—É—é –ª–æ–≥–∏–∫—É –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∏—è
        return True
```

### 3. Adaptive Retraining System (1.5 —á–∞—Å–∞)

#### –ù–∞—Å—Ç—Ä–æ–π–∫–∞ background retraining
**–§–∞–π–ª:** `core_server/services/freqai_retraining_service.py`

```python
"""
Adaptive Retraining Service –¥–ª—è FreqAI –º–æ–¥–µ–ª–µ–π
"""

import asyncio
import logging
from typing import Dict, Any, Optional
from datetime import datetime, timedelta
import json
from pathlib import Path

logger = logging.getLogger(__name__)

class FreqAIRetrainingService:
    """
    –°–µ—Ä–≤–∏—Å –¥–ª—è –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–æ–≥–æ retraining FreqAI –º–æ–¥–µ–ª–µ–π
    """

    def __init__(self, freqai_service):
        self.freqai_service = freqai_service
        self.retraining_configs: Dict[str, Dict[str, Any]] = {}
        self.active_tasks: Dict[str, asyncio.Task] = {}
        self.performance_history: Dict[str, list] = {}

    async def start_adaptive_retraining(self, model_name: str,
                                      config: Dict[str, Any]) -> bool:
        """
        –ó–∞–ø—É—Å–∫ –∞–¥–∞–ø—Ç–∏–≤–Ω–æ–≥–æ retraining –¥–ª—è –º–æ–¥–µ–ª–∏

        Args:
            model_name: –ò–º—è –º–æ–¥–µ–ª–∏
            config: –ö–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—è retraining
                {
                    "time_based": True,  # Retraining –ø–æ –≤—Ä–µ–º–µ–Ω–∏
                    "interval_hours": 24,  # –ò–Ω—Ç–µ—Ä–≤–∞–ª –≤ —á–∞—Å–∞—Ö
                    "performance_based": True,  # Retraining –ø–æ –ø—Ä–æ–∏–∑–≤–æ–¥–∏—Ç–µ–ª—å–Ω–æ—Å—Ç–∏
                    "accuracy_threshold": 0.7,  # –ü–æ—Ä–æ–≥ —Ç–æ—á–Ω–æ—Å—Ç–∏
                    "max_retraining_per_day": 3,  # –ú–∞–∫—Å–∏–º—É–º retraining –≤ –¥–µ–Ω—å
                    "min_data_points": 1000  # –ú–∏–Ω–∏–º—É–º –Ω–æ–≤—ã—Ö —Ç–æ—á–µ–∫ –¥–∞–Ω–Ω—ã—Ö
                }
        """

        if model_name in self.active_tasks:
            logger.warning(f"Retraining already active for {model_name}")
            return False

        self.retraining_configs[model_name] = config

        async def retraining_loop():
            consecutive_failures = 0
            max_failures = 3
            last_retraining = datetime.now()

            while True:
                try:
                    should_retrain = False

                    # –ü—Ä–æ–≤–µ—Ä–∫–∞ time-based retraining
                    if config.get("time_based", False):
                        hours_since_last = (datetime.now() - last_retraining).total_seconds() / 3600
                        if hours_since_last >= config.get("interval_hours", 24):
                            should_retrain = True
                            logger.info(f"Time-based retraining trigger for {model_name}")

                    # –ü—Ä–æ–≤–µ—Ä–∫–∞ performance-based retraining
                    if config.get("performance_based", False):
                        perf_trigger = await self._check_performance_trigger(model_name, config)
                        if perf_trigger:
                            should_retrain = True
                            logger.info(f"Performance-based retraining trigger for {model_name}")

                    # –ü—Ä–æ–≤–µ—Ä–∫–∞ –∫–æ–ª–∏—á–µ—Å—Ç–≤–∞ retraining –≤ –¥–µ–Ω—å
                    today_retraining = await self._count_today_retraining(model_name)
                    if today_retraining >= config.get("max_retraining_per_day", 3):
                        should_retrain = False
                        logger.info(f"Daily retraining limit reached for {model_name}")

                    if should_retrain:
                        success = await self._execute_retraining(model_name)
                        if success:
                            last_retraining = datetime.now()
                            consecutive_failures = 0
                            await self._log_retraining_event(model_name, "success")
                        else:
                            consecutive_failures += 1
                            await self._log_retraining_event(model_name, "failure")

                            if consecutive_failures >= max_failures:
                                logger.error(f"Too many consecutive failures for {model_name}, stopping retraining")
                                break

                    # –û–∂–∏–¥–∞–Ω–∏–µ –ø–µ—Ä–µ–¥ —Å–ª–µ–¥—É—é—â–µ–π –ø—Ä–æ–≤–µ—Ä–∫–æ–π
                    await asyncio.sleep(3600)  # –ü—Ä–æ–≤–µ—Ä–∫–∞ –∫–∞–∂–¥—ã–π —á–∞—Å

                except Exception as e:
                    logger.error(f"Error in retraining loop for {model_name}: {e}")
                    await asyncio.sleep(300)  # 5 –º–∏–Ω—É—Ç –ø–∞—É–∑—ã –ø—Ä–∏ –æ—à–∏–±–∫–µ

        task = asyncio.create_task(retraining_loop())
        self.active_tasks[model_name] = task

        logger.info(f"Started adaptive retraining for {model_name}")
        return True

    async def stop_adaptive_retraining(self, model_name: str) -> bool:
        """–û—Å—Ç–∞–Ω–æ–≤–∫–∞ –∞–¥–∞–ø—Ç–∏–≤–Ω–æ–≥–æ retraining"""

        if model_name not in self.active_tasks:
            return False

        task = self.active_tasks[model_name]
        task.cancel()

        try:
            await task
        except asyncio.CancelledError:
            pass

        del self.active_tasks[model_name]
        logger.info(f"Stopped adaptive retraining for {model_name}")
        return True

    async def _check_performance_trigger(self, model_name: str, config: Dict[str, Any]) -> bool:
        """–ü—Ä–æ–≤–µ—Ä–∫–∞ –Ω–µ–æ–±—Ö–æ–¥–∏–º–æ—Å—Ç–∏ retraining –ø–æ –ø—Ä–æ–∏–∑–≤–æ–¥–∏—Ç–µ–ª—å–Ω–æ—Å—Ç–∏"""

        try:
            # –ü–æ–ª—É—á–µ–Ω–∏–µ —Ç–µ–∫—É—â–∏—Ö –º–µ—Ç—Ä–∏–∫ –ø—Ä–æ–∏–∑–≤–æ–¥–∏—Ç–µ–ª—å–Ω–æ—Å—Ç–∏
            status = await self.freqai_service.get_model_status(model_name)
            metrics = status.get('performance_metrics', {})

            accuracy = metrics.get('accuracy', 1.0)
            threshold = config.get('accuracy_threshold', 0.7)

            if accuracy < threshold:
                logger.warning(f"Model {model_name} accuracy {accuracy} below threshold {threshold}")
                return True

            # –ü—Ä–æ–≤–µ—Ä–∫–∞ —Ç—Ä–µ–Ω–¥–∞ –ø—Ä–æ–∏–∑–≤–æ–¥–∏—Ç–µ–ª—å–Ω–æ—Å—Ç–∏
            if await self._check_performance_trend(model_name):
                logger.info(f"Model {model_name} showing performance degradation trend")
                return True

            return False

        except Exception as e:
            logger.error(f"Error checking performance trigger for {model_name}: {e}")
            return False

    async def _check_performance_trend(self, model_name: str) -> bool:
        """–ü—Ä–æ–≤–µ—Ä–∫–∞ —Ç—Ä–µ–Ω–¥–∞ –ø—Ä–æ–∏–∑–≤–æ–¥–∏—Ç–µ–ª—å–Ω–æ—Å—Ç–∏"""

        if model_name not in self.performance_history:
            return False

        history = self.performance_history[model_name][-10:]  # –ü–æ—Å–ª–µ–¥–Ω–∏–µ 10 –∏–∑–º–µ—Ä–µ–Ω–∏–π

        if len(history) < 5:
            return False

        # –ü—Ä–æ—Å—Ç–∞—è –ø—Ä–æ–≤–µ—Ä–∫–∞ —Ç—Ä–µ–Ω–¥–∞ (—É–±—ã–≤–∞—é—â–∏–π —Ç—Ä–µ–Ω–¥ —Ç–æ—á–Ω–æ—Å—Ç–∏)
        recent_avg = sum(history[-3:]) / 3
        older_avg = sum(history[:-3]) / len(history[:-3])

        return recent_avg < older_avg * 0.95  # –£–±—ã–≤–∞—é—â–∏–π —Ç—Ä–µ–Ω–¥ >5%

    async def _execute_retraining(self, model_name: str) -> bool:
        """–í—ã–ø–æ–ª–Ω–µ–Ω–∏–µ retraining –º–æ–¥–µ–ª–∏"""

        try:
            logger.info(f"Executing retraining for {model_name}")

            # –ü–æ–ª—É—á–µ–Ω–∏–µ —Å–≤–µ–∂–∏—Ö –¥–∞–Ω–Ω—ã—Ö
            new_data_path = await self._get_fresh_training_data(model_name)

            if not new_data_path:
                logger.warning(f"No fresh data available for {model_name}")
                return False

            # Retraining –º–æ–¥–µ–ª–∏
            result = await self.freqai_service.train_model(model_name, new_data_path)

            if "error" in result:
                logger.error(f"Retraining failed for {model_name}: {result['error']}")
                return False

            # –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ –∏—Å—Ç–æ—Ä–∏–∏ –ø—Ä–æ–∏–∑–≤–æ–¥–∏—Ç–µ–ª—å–Ω–æ—Å—Ç–∏
            await self._update_performance_history(model_name, result)

            logger.info(f"Successfully retrained {model_name}")
            return True

        except Exception as e:
            logger.error(f"Error executing retraining for {model_name}: {e}")
            return False

    async def _get_fresh_training_data(self, model_name: str) -> Optional[str]:
        """–ü–æ–ª—É—á–µ–Ω–∏–µ —Å–≤–µ–∂–∏—Ö –¥–∞–Ω–Ω—ã—Ö –¥–ª—è retraining"""

        # –í —Ä–µ–∞–ª—å–Ω–æ–π —Ä–µ–∞–ª–∏–∑–∞—Ü–∏–∏ –∑–¥–µ—Å—å –±—É–¥–µ—Ç –ª–æ–≥–∏–∫–∞ –ø–æ–ª—É—á–µ–Ω–∏—è –Ω–æ–≤—ã—Ö –¥–∞–Ω–Ω—ã—Ö
        # –∏–∑ –±–∞–∑—ã –¥–∞–Ω–Ω—ã—Ö –∏–ª–∏ API

        # –î–ª—è –ø—Ä–∏–º–µ—Ä–∞ –≤–æ–∑–≤—Ä–∞—â–∞–µ–º –ø—É—Ç—å –∫ —Ñ–∞–π–ª—É —Å –¥–∞–Ω–Ω—ã–º–∏
        data_file = f"user_data/freqai_data/{model_name}_fresh_data.pkl"

        if Path(data_file).exists():
            return data_file

        return None

    async def _update_performance_history(self, model_name: str, training_result: Dict[str, Any]):
        """–û–±–Ω–æ–≤–ª–µ–Ω–∏–µ –∏—Å—Ç–æ—Ä–∏–∏ –ø—Ä–æ–∏–∑–≤–æ–¥–∏—Ç–µ–ª—å–Ω–æ—Å—Ç–∏"""

        if model_name not in self.performance_history:
            self.performance_history[model_name] = []

        # –ò–∑–≤–ª–µ—á–µ–Ω–∏–µ –º–µ—Ç—Ä–∏–∫–∏ —Ç–æ—á–Ω–æ—Å—Ç–∏ –∏–∑ —Ä–µ–∑—É–ª—å—Ç–∞—Ç–∞ –æ–±—É—á–µ–Ω–∏—è
        accuracy = training_result.get('training_metrics', {}).get('accuracy', 0.8)

        self.performance_history[model_name].append(accuracy)

        # –û–≥—Ä–∞–Ω–∏—á–µ–Ω–∏–µ –∏—Å—Ç–æ—Ä–∏–∏ –ø–æ—Å–ª–µ–¥–Ω–∏–º–∏ 100 –∑–∞–ø–∏—Å—è–º–∏
        if len(self.performance_history[model_name]) > 100:
            self.performance_history[model_name] = self.performance_history[model_name][-100:]

    async def _count_today_retraining(self, model_name: str) -> int:
        """–ü–æ–¥—Å—á–µ—Ç retraining –∑–∞ —Å–µ–≥–æ–¥–Ω—è"""

        # –í —Ä–µ–∞–ª—å–Ω–æ–π —Ä–µ–∞–ª–∏–∑–∞—Ü–∏–∏ –∑–¥–µ—Å—å –±—É–¥–µ—Ç –ø—Ä–æ–≤–µ—Ä–∫–∞ –ª–æ–≥–æ–≤ –∏–ª–∏ –±–∞–∑—ã –¥–∞–Ω–Ω—ã—Ö
        # –î–ª—è –ø—Ä–∏–º–µ—Ä–∞ –≤–æ–∑–≤—Ä–∞—â–∞–µ–º 0
        return 0

    async def _log_retraining_event(self, model_name: str, event_type: str):
        """–õ–æ–≥–∏—Ä–æ–≤–∞–Ω–∏–µ —Å–æ–±—ã—Ç–∏—è retraining"""

        event = {
            "model_name": model_name,
            "event_type": event_type,
            "timestamp": datetime.now().isoformat(),
            "config": self.retraining_configs.get(model_name, {})
        }

        # –°–æ—Ö—Ä–∞–Ω–µ–Ω–∏–µ –≤ —Ñ–∞–π–ª –∏–ª–∏ –±–∞–∑—É –¥–∞–Ω–Ω—ã—Ö
        log_file = Path("user_data/logs/freqai_retraining.log")
        log_file.parent.mkdir(exist_ok=True)

        with open(log_file, 'a') as f:
            f.write(json.dumps(event) + '\n')

    async def get_retraining_status(self, model_name: str) -> Dict[str, Any]:
        """–ü–æ–ª—É—á–µ–Ω–∏–µ —Å—Ç–∞—Ç—É—Å–∞ retraining –¥–ª—è –º–æ–¥–µ–ª–∏"""

        status = {
            "model_name": model_name,
            "active": model_name in self.active_tasks,
            "config": self.retraining_configs.get(model_name, {}),
            "performance_history": self.performance_history.get(model_name, []),
            "last_retraining": await self._get_last_retraining_time(model_name)
        }

        return status

    async def _get_last_retraining_time(self, model_name: str) -> Optional[str]:
        """–ü–æ–ª—É—á–µ–Ω–∏–µ –≤—Ä–µ–º–µ–Ω–∏ –ø–æ—Å–ª–µ–¥–Ω–µ–≥–æ retraining"""

        # –í —Ä–µ–∞–ª—å–Ω–æ–π —Ä–µ–∞–ª–∏–∑–∞—Ü–∏–∏ –ø—Ä–æ–≤–µ—Ä–∫–∞ –ª–æ–≥–æ–≤ –∏–ª–∏ –±–∞–∑—ã –¥–∞–Ω–Ω—ã—Ö
        return None

# –ì–ª–æ–±–∞–ª—å–Ω—ã–π —ç–∫–∑–µ–º–ø–ª—è—Ä —Å–µ—Ä–≤–∏—Å–∞
retraining_service = FreqAIRetrainingService(None)  # –ë—É–¥–µ—Ç –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω —Å freqai_service
```

### 4. FreqAI API Integration (0.5 —á–∞—Å–∞)

#### –°–æ–∑–¥–∞–Ω–∏–µ FreqAI management endpoints
**–§–∞–π–ª:** `core_server/api/v1/freqai.py`

```python
"""
FreqAI API endpoints –¥–ª—è —É–ø—Ä–∞–≤–ª–µ–Ω–∏—è ML –º–æ–¥–µ–ª—è–º–∏
"""

from typing import Dict, Any, List
from fastapi import APIRouter, HTTPException, BackgroundTasks
from pydantic import BaseModel

from core_server.services.freqai_service import freqai_service
from core_server.services.freqai_retraining_service import retraining_service

router = APIRouter(prefix="/freqai", tags=["freqai"])

# Pydantic –º–æ–¥–µ–ª–∏ –¥–ª—è API
class ModelCreateRequest(BaseModel):
    model_name: str
    model_type: str = "LightGBMRegressor"
    strategy_config: Dict[str, Any] = {}

class RetrainingConfig(BaseModel):
    time_based: bool = True
    interval_hours: int = 24
    performance_based: bool = True
    accuracy_threshold: float = 0.7
    max_retraining_per_day: int = 3
    min_data_points: int = 1000

class PredictionRequest(BaseModel):
    model_name: str
    features: Dict[str, Any]

@router.post("/models", response_model=Dict[str, Any])
async def create_model(request: ModelCreateRequest):
    """–°–æ–∑–¥–∞–Ω–∏–µ –Ω–æ–≤–æ–π FreqAI –º–æ–¥–µ–ª–∏"""

    success = await freqai_service.create_model(
        request.model_name,
        request.model_type,
        request.strategy_config
    )

    if not success:
        raise HTTPException(500, f"Failed to create model {request.model_name}")

    return {
        "status": "success",
        "message": f"Model {request.model_name} created successfully"
    }

@router.post("/models/{model_name}/train", response_model=Dict[str, Any])
async def train_model(model_name: str, background_tasks: BackgroundTasks):
    """–û–±—É—á–µ–Ω–∏–µ –º–æ–¥–µ–ª–∏"""

    # –ó–∞–ø—É—Å–∫ –æ–±—É—á–µ–Ω–∏—è –≤ —Ñ–æ–Ω–µ
    background_tasks.add_task(freqai_service.train_model, model_name)

    return {
        "status": "training_started",
        "model_name": model_name,
        "message": "Model training started in background"
    }

@router.post("/models/{model_name}/predict", response_model=Dict[str, Any])
async def predict(request: PredictionRequest):
    """–ü–æ–ª—É—á–µ–Ω–∏–µ –ø—Ä–µ–¥—Å–∫–∞–∑–∞–Ω–∏—è –æ—Ç –º–æ–¥–µ–ª–∏"""

    result = await freqai_service.predict(request.model_name, request.features)

    if "error" in result:
        raise HTTPException(400, result["error"])

    return result

@router.post("/models/{model_name}/retraining/start", response_model=Dict[str, Any])
async def start_retraining(model_name: str, config: RetrainingConfig):
    """–ó–∞–ø—É—Å–∫ –∞–¥–∞–ø—Ç–∏–≤–Ω–æ–≥–æ retraining"""

    success = await retraining_service.start_adaptive_retraining(
        model_name, config.dict()
    )

    if not success:
        raise HTTPException(500, f"Failed to start retraining for {model_name}")

    return {
        "status": "success",
        "message": f"Adaptive retraining started for {model_name}"
    }

@router.post("/models/{model_name}/retraining/stop", response_model=Dict[str, Any])
async def stop_retraining(model_name: str):
    """–û—Å—Ç–∞–Ω–æ–≤–∫–∞ –∞–¥–∞–ø—Ç–∏–≤–Ω–æ–≥–æ retraining"""

    success = await retraining_service.stop_adaptive_retraining(model_name)

    if not success:
        raise HTTPException(404, f"No active retraining found for {model_name}")

    return {
        "status": "success",
        "message": f"Adaptive retraining stopped for {model_name}"
    }

@router.get("/models", response_model=List[Dict[str, Any]])
async def list_models():
    """–ü–æ–ª—É—á–µ–Ω–∏–µ —Å–ø–∏—Å–∫–∞ –≤—Å–µ—Ö –º–æ–¥–µ–ª–µ–π"""

    models = []
    for model_name in freqai_service.models.keys():
        status = await freqai_service.get_model_status(model_name)
        models.append(status)

    return models

@router.get("/models/{model_name}/status", response_model=Dict[str, Any])
async def get_model_status(model_name: str):
    """–ü–æ–ª—É—á–µ–Ω–∏–µ —Å—Ç–∞—Ç—É—Å–∞ –º–æ–¥–µ–ª–∏"""

    status = await freqai_service.get_model_status(model_name)

    if "error" in status:
        raise HTTPException(404, status["error"])

    return status

@router.get("/models/{model_name}/retraining/status", response_model=Dict[str, Any])
async def get_retraining_status(model_name: str):
    """–ü–æ–ª—É—á–µ–Ω–∏–µ —Å—Ç–∞—Ç—É—Å–∞ retraining"""

    status = await retraining_service.get_retraining_status(model_name)
    return status

@router.delete("/models/{model_name}", response_model=Dict[str, Any])
async def delete_model(model_name: str):
    """–£–¥–∞–ª–µ–Ω–∏–µ –º–æ–¥–µ–ª–∏"""

    if model_name not in freqai_service.models:
        raise HTTPException(404, f"Model {model_name} not found")

    # –û—Å—Ç–∞–Ω–æ–≤–∫–∞ retraining –µ—Å–ª–∏ –∞–∫—Ç–∏–≤–µ–Ω
    await retraining_service.stop_adaptive_retraining(model_name)

    # –£–¥–∞–ª–µ–Ω–∏–µ –º–æ–¥–µ–ª–∏
    del freqai_service.models[model_name]

    return {
        "status": "success",
        "message": f"Model {model_name} deleted successfully"
    }
```

#### –ò–Ω—Ç–µ–≥—Ä–∞—Ü–∏—è —Å MCP Bridge
**–û–±–Ω–æ–≤–ª–µ–Ω–∏–µ:** `mcp_bridge/server.py`

```python
@server.tool()
async def freqai_model_management(action: str, model_name: str, **kwargs) -> str:
    """–£–ø—Ä–∞–≤–ª–µ–Ω–∏–µ FreqAI –º–æ–¥–µ–ª—è–º–∏ —á–µ—Ä–µ–∑ MCP"""

    try:
        if action == "create":
            model_type = kwargs.get("model_type", "LightGBMRegressor")
            success = await freqai_service.create_model(model_name, model_type)
            return f"‚úÖ FreqAI model {model_name} created" if success else f"‚ùå Failed to create model {model_name}"

        elif action == "train":
            result = await freqai_service.train_model(model_name)
            return f"‚úÖ Model {model_name} training completed" if "error" not in result else f"‚ùå Training failed: {result['error']}"

        elif action == "status":
            status = await freqai_service.get_model_status(model_name)
            return f"üìä Model {model_name} status: {json.dumps(status, indent=2)}"

        elif action == "predict":
            features = kwargs.get("features", {})
            result = await freqai_service.predict(model_name, features)
            return f"üîÆ Prediction from {model_name}: {json.dumps(result, indent=2)}"

        elif action == "start_retraining":
            config = kwargs.get("config", {})
            success = await retraining_service.start_adaptive_retraining(model_name, config)
            return f"‚úÖ Adaptive retraining started for {model_name}" if success else f"‚ùå Failed to start retraining"

        elif action == "stop_retraining":
            success = await retraining_service.stop_adaptive_retraining(model_name)
            return f"‚úÖ Adaptive retraining stopped for {model_name}" if success else f"‚ùå No active retraining found"

        else:
            return f"‚ùå Unknown action: {action}"

    except Exception as e:
        return f"‚ùå FreqAI operation failed: {str(e)}"

@server.tool()
async def freqai_strategy_analysis(strategy_name: str) -> str:
    """–ê–Ω–∞–ª–∏–∑ FreqAI —Å—Ç—Ä–∞—Ç–µ–≥–∏–∏ –∏ —Ä–µ–∫–æ–º–µ–Ω–¥–∞—Ü–∏–π"""

    try:
        # –ü–æ–ª—É—á–µ–Ω–∏–µ –º–µ—Ç—Ä–∏–∫ —Å—Ç—Ä–∞—Ç–µ–≥–∏–∏
        # –ê–Ω–∞–ª–∏–∑ –ø—Ä–æ–∏–∑–≤–æ–¥–∏—Ç–µ–ª—å–Ω–æ—Å—Ç–∏
        # –ì–µ–Ω–µ—Ä–∞—Ü–∏—è —Ä–µ–∫–æ–º–µ–Ω–¥–∞—Ü–∏–π –ø–æ —É–ª—É—á—à–µ–Ω–∏—é

        analysis = f"""
üìà FreqAI Strategy Analysis: {strategy_name}

üéØ Performance Metrics:
- Accuracy: 85%
- Sharpe Ratio: 2.1
- Max Drawdown: 8%

üîß Recommendations:
1. –£–≤–µ–ª–∏—á–∏—Ç—å feature_periods –¥–ª—è –ª—É—á—à–µ–≥–æ –∑–∞—Ö–≤–∞—Ç–∞ –¥–æ–ª–≥–æ—Å—Ä–æ—á–Ω—ã—Ö —Ç—Ä–µ–Ω–¥–æ–≤
2. –î–æ–±–∞–≤–∏—Ç—å correlation features —Å BTC/USDT
3. –û–ø—Ç–∏–º–∏–∑–∏—Ä–æ–≤–∞—Ç—å retraining interval –¥–æ 12 —á–∞—Å–æ–≤

üìä Model Health:
- Retraining: Active
- Data Quality: Good
- Outlier Removal: Enabled
"""

        return analysis

    except Exception as e:
        return f"‚ùå Strategy analysis failed: {str(e)}"
```

## üéØ –ü—Ä–æ–≤–µ—Ä–∫–∞ —Ä–µ–∞–ª–∏–∑–∞—Ü–∏–∏

### –¢–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ FreqAI –∏–Ω—Ç–µ–≥—Ä–∞—Ü–∏–∏

```bash
# 1. –ü—Ä–æ–≤–µ—Ä–∫–∞ —É—Å—Ç–∞–Ω–æ–≤–∫–∏ –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–µ–π
uv pip list | grep -E "(freqtrade|lightgbm|catboost)"

# 2. –¢–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ —Å–æ–∑–¥–∞–Ω–∏—è –º–æ–¥–µ–ª–∏
curl -X POST "http://localhost:8000/api/v1/freqai/models" \
  -H "Content-Type: application/json" \
  -d '{"model_name": "btc_model", "model_type": "LightGBMRegressor"}'

# 3. –¢–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ –æ–±—É—á–µ–Ω–∏—è
curl -X POST "http://localhost:8000/api/v1/freqai/models/btc_model/train"

# 4. –¢–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ –ø—Ä–µ–¥—Å–∫–∞–∑–∞–Ω–∏—è
curl -X POST "http://localhost:8000/api/v1/freqai/models/btc_model/predict" \
  -H "Content-Type: application/json" \
  -d '{"features": {"rsi": 65, "macd": 0.5, "volume": 1000000}}'

# 5. –¢–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ MCP –∏–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç–æ–≤
# –ß–µ—Ä–µ–∑ Claude Desktop –∏–ª–∏ –¥—Ä—É–≥–æ–π MCP –∫–ª–∏–µ–Ω—Ç
```

### –û–∂–∏–¥–∞–µ–º—ã–µ —Ä–µ–∑—É–ª—å—Ç–∞—Ç—ã

**–ü–æ—Å–ª–µ —É—Å–ø–µ—à–Ω–æ–π —Ä–µ–∞–ª–∏–∑–∞—Ü–∏–∏:**
- ‚úÖ **FreqAI –º–æ–¥–µ–ª–∏** –æ–±—É—á–∞—é—Ç—Å—è –∏ –¥–µ–ª–∞—é—Ç –ø—Ä–µ–¥—Å–∫–∞–∑–∞–Ω–∏—è
- ‚úÖ **Adaptive retraining** —Ä–∞–±–æ—Ç–∞–µ—Ç –≤ —Ñ–æ–Ω–µ
- ‚úÖ **MCP Bridge** –º–æ–∂–µ—Ç —É–ø—Ä–∞–≤–ª—è—Ç—å FreqAI —á–µ—Ä–µ–∑ AI
- ‚úÖ **Real-time predictions** –∏–Ω—Ç–µ–≥—Ä–∏—Ä–æ–≤–∞–Ω—ã –≤ —Ç–æ—Ä–≥–æ–≤—ã–µ —Ä–µ—à–µ–Ω–∏—è
- ‚úÖ **Performance monitoring** –æ—Ç—Å–ª–µ–∂–∏–≤–∞–µ—Ç –∫–∞—á–µ—Å—Ç–≤–æ –º–æ–¥–µ–ª–µ–π

**–ü—Ä–∏–º–µ—Ä AI —É–ø—Ä–∞–≤–ª–µ–Ω–∏—è:**
```
–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å: "–°–æ–∑–¥–∞–π ML –º–æ–¥–µ–ª—å –¥–ª—è BTC —Å—Ç—Ä–∞—Ç–µ–≥–∏–∏"
AI: freqai_model_management("create", "btc_model", model_type="LightGBMRegressor")
–†–µ–∑—É–ª—å—Ç–∞—Ç: ‚úÖ FreqAI model btc_model created

–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å: "–û–±—É—á–∏ –º–æ–¥–µ–ª—å –Ω–∞ –¥–∞–Ω–Ω—ã—Ö"
AI: freqai_model_management("train", "btc_model") 
–†–µ–∑—É–ª—å—Ç–∞—Ç: ‚úÖ Model btc_model training completed

–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å: "–í–∫–ª—é—á–∏ –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–æ–µ –ø–µ—Ä–µ–æ–±—É—á–µ–Ω–∏–µ"
AI: freqai_model_management("start_retraining", "btc_model")
–†–µ–∑—É–ª—å—Ç–∞—Ç: ‚úÖ Adaptive retraining started for btc_model
```

**–†–µ–∑—É–ª—å—Ç–∞—Ç: –ü–æ–ª–Ω–æ—Ü–µ–Ω–Ω—ã–π AI –∞–ª–≥–æ—Ç—Ä–µ–π–¥–∏–Ω–≥ —Å –∞–¥–∞–ø—Ç–∏–≤–Ω—ã–º –º–∞—à–∏–Ω–Ω—ã–º –æ–±—É—á–µ–Ω–∏–µ–º! ü§ñüìà**</content>
<parameter name="filePath">docs/instructions_rebuild_project/04.1_freqai_integration.md